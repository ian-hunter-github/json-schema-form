=======
package.json
{
  "name": "json-schema-form-monorepo",
  "private": true,
  "workspaces": [
    "packages/*",
    "examples/*"
  ],
  "scripts": {
    "build:core": "npm --workspace @ianhunterpersonal/jsf-core run build",
    "build:react": "npm --workspace @ianhunterpersonal/jsf-react run build",
    "build:vanilla": "npm --workspace @ianhunterpersonal/jsf-vanilla run build",
    "build:webc": "npm --workspace @ianhunterpersonal/jsf-webc run build",
    "build:examples": "npm --workspace examples/react run build",
    "build": "npm run build:core && npm run build:react && npm run build:vanilla && npm run build:webc && npm run build:examples",
    "dev:react": "npm --workspace examples/react run dev",
    "clean": "rimraf packages/*/dist"
  },
  "devDependencies": {
    "rimraf": "^6.0.1",
    "tsup": "^8.5.0",
    "typescript": "^5.5.4",
    "@types/node": "^20.14.12",
    "vitest": "^2.0.5",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0"
  }
}=======
tsconfig.base.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "declaration": true,
    "sourceMap": true,
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "types": ["node"]
  }
}
=======
packages/jsf-core/package.json
{
  "name": "@ianhunterpersonal/jsf-core",
  "version": "0.0.1-beta.1",
  "type": "module",
  "main": "dist/index.cjs",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs",
      "types": "./dist/index.d.ts"
    }
  },
  "files": [
    "dist",
    "README.md",
    "LICENSE"
  ],
  "scripts": {
    "build": "tsup src/index.ts --dts --format esm,cjs --clean"
  },
  "dependencies": {
    "ajv": "^8.17.1",
    "ajv-formats": "^2.1.1",
    "fast-deep-equal": "^3.1.3"
  },
  "devDependencies": {
    "@types/node": "^20.19.10",
    "tsup": "^8.5.0",
    "typescript": "^5.9.2"
  },
  "publishConfig": {
    "access": "public",
    "tag": "experimental"
  }
}
=======
packages/jsf-core/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "module": "ESNext",
    "moduleResolution": "Bundler"
  },
  "include": [
    "src"
  ]
}=======
packages/jsf-core/src/utils.ts
import deepEqual from "fast-deep-equal";

export const toPath = (p: string | (string|number)[]): string =>
  Array.isArray(p) ? p.map(seg => String(seg)).join(".") : p;

export const splitPath = (p: string): (string|number)[] =>
  p === "" ? [] : p.split(".").map(seg => (seg.match(/^\d+$/) ? Number(seg) : seg));

export function getByPath(obj: any, path: string) {
  const segs = splitPath(path);
  let cur = obj;
  for (const s of segs) {
    if (cur == null) return undefined;
    cur = cur[s as any];
  }
  return cur;
}

export function setByPath(obj: any, path: string, value: any) {
  const segs = splitPath(path);
  if (segs.length === 0) return value;
  let cur = obj;
  for (let i = 0; i < segs.length - 1; i++) {
    const s = segs[i];
    const next = segs[i+1];
    if (cur[s as any] == null) {
      cur[s as any] = typeof next === "number" ? [] : {};
    }
    cur = cur[s as any];
  }
  (cur as any)[segs[segs.length - 1] as any] = value;
  return obj;
}

export function deleteByPath(obj: any, path: string) {
  const segs = splitPath(path);
  if (segs.length === 0) return;
  let cur = obj;
  for (let i = 0; i < segs.length - 1; i++) {
    const s = segs[i];
    if (cur[s as any] == null) return;
    cur = cur[s as any];
  }
  const last = segs[segs.length - 1] as any;
  if (Array.isArray(cur) && typeof last === "number") {
    cur.splice(last, 1);
  } else {
    delete (cur as any)[last];
  }
}

export const isObject = (v: any) => v && typeof v === "object" && !Array.isArray(v);

export const applyDefaults = (schema: any, data: any): any => {
  if (schema == null) return data;
  if (data == null && schema.default !== undefined) return structuredClone(schema.default);
  if (Array.isArray(data)) {
    const itemSchema = schema.items;
    return data.map(it => applyDefaults(itemSchema, it));
  }
  if (isObject(data)) {
    const result: any = { ...data };
    const props = schema.properties || {};
    for (const key of Object.keys(props)) {
      result[key] = applyDefaults((props as any)[key], result[key]);
    }
    return result;
  }
  return data;
};

export function sanitizeId(path: string): string {
  return path.replace(/[^a-zA-Z0-9\-_:.]/g, "_");
}

export function shallowEqual(a: any, b: any) {
  if (a === b) return true;
  if (!a || !b) return false;
  const ak = Object.keys(a);
  const bk = Object.keys(b);
  if (ak.length !== bk.length) return false;
  for (const k of ak) if ((a as any)[k] !== (b as any)[k]) return false;
  return true;
}

export function clone<T>(v: T): T {
  return structuredClone(v);
}

export { deepEqual };
=======
packages/jsf-core/src/engine.ts
import Ajv, { ErrorObject } from "ajv";
import addFormats from "ajv-formats";
import { applyDefaults, clone, getByPath, setByPath } from "./utils";
import type { Engine, EngineOptions, FormState, JSONSchema, Path, ValidationError } from "./types";

type CacheKey = string;
const ajvCache = new Map<CacheKey, Ajv>();

function makeAjv(schema: JSONSchema): Ajv {
  const key = String((schema as any)?.$id || "no-id");
  if (ajvCache.has(key)) return ajvCache.get(key)!;

  // Allow vendor extensions and stay permissive for UX widgets
  const ajv = new Ajv({
    strict: false,            // <-- allow unknown keywords like x-*
    allErrors: true,
    allowUnionTypes: true
  });
  addFormats(ajv);

  // Whitelist vendor/interop keywords so strict mode never complains if toggled later
  ["x-enumNames", "x-enum-labels", "discriminator"].forEach((k) => {
    try { (ajv as any).addKeyword(k); } catch {}
  });

  ajvCache.set(key, ajv);
  return ajv;
}

function mapErrors(errs: ErrorObject[] | null | undefined): ValidationError[] {
  if (!errs) return [];
  return errs.map(e => {
    const path = (e.instancePath || "").replace(/^\//, "").replace(/\//g, ".").replace(/\[(\d+)\]/g, ".$1");
    const missing = (e.params as any)?.missingProperty;
    const finalPath = missing ? (path ? `${path}.${missing}` : missing) : path;
    return { path: finalPath, message: e.message || "Invalid", keyword: e.keyword };
  });
}

export function createEngine(schema: JSONSchema, initialData: any = {}, opts: EngineOptions = {}): Engine {
  let _schema = schema;
  const ajv = makeAjv(_schema);
  const validateRoot = ajv.compile(_schema);

  const state: FormState = {
    data: applyDefaults(_schema, clone(initialData)),
    dirty: new Set<string>(),
    errors: [],
    activeOneOf: {}
  };

  function validate(): boolean {
    const ok = validateRoot(state.data);
    state.errors = mapErrors(validateRoot.errors);
    return !!ok;
  }

  function setValue(path: Path, value: any) {
    state.data = setByPath(clone(state.data), path, value);
    state.dirty.add(path);
    validate();
  }

  function addArrayItem(path: Path, value?: any) {
    const next = clone(state.data);
    const nextArr = getByPath(next, path) || [];
    if (!Array.isArray(nextArr)) throw new Error(`Path ${path} is not an array`);
    nextArr.push(value);
    setByPath(next, path, nextArr);
    state.data = next;
    state.dirty.add(path);
    validate();
  }

  function removeArrayItem(path: Path, index: number) {
    const next = clone(state.data);
    const arr = getByPath(next, path);
    if (!Array.isArray(arr)) throw new Error(`Path ${path} is not an array`);
    arr.splice(index, 1);
    setByPath(next, path, arr);
    state.data = next;
    state.dirty.add(path);
    validate();
  }

  function setActiveBranch(containerPath: Path, index: number) {
    state.activeOneOf[containerPath] = index;
    validate();
  }

  function getErrors() { return state.errors; }
  function getState() { return state; }
  function getSchema() { return _schema; }

  function setSchema(s: JSONSchema) {
    _schema = s;
    ajv.removeSchema();
    validateRoot.schema = _schema;
    validateRoot.errors = null;
    state.data = applyDefaults(_schema, state.data);
    state.errors = [];
    state.activeOneOf = {};
    validate();
  }

  function reset(data?: any) {
    state.data = applyDefaults(_schema, data ?? {});
    state.errors = [];
    state.dirty = new Set();
    validate();
  }

  validate();
  return { getState, setValue, addArrayItem, removeArrayItem, setActiveBranch, validate, getErrors, getSchema, setSchema, reset };
}
=======
packages/jsf-core/src/types.ts
export type JSONSchema = any; // Draft-07+

export type Path = string;

export interface ValidationError {
  path: Path;
  message: string;
  keyword: string;
}

export interface EngineOptions {
  allowExternalRefs?: boolean;
  debounceMs?: number;
  keepDataOnOneOfSwitch?: boolean;
  debug?: boolean;
}

export interface FormState {
  data: any;
  dirty: Set<string>;
  errors: ValidationError[];
  activeOneOf: Record<Path, number>;
}

export interface Engine {
  getState(): FormState;
  setValue(path: Path, value: any): void;
  addArrayItem(path: Path, value?: any): void;
  removeArrayItem(path: Path, index: number): void;
  setActiveBranch(containerPath: Path, index: number): void;
  validate(): boolean;
  getErrors(): ValidationError[];
  getSchema(): JSONSchema;
  setSchema(schema: JSONSchema): void;
  reset(data?: any): void;
}
=======
packages/jsf-core/src/index.ts
export * from "./types";
export * from "./utils";
export { createEngine } from "./engine";
=======
packages/jsf-vanilla/package.json
{
  "name": "@ianhunterpersonal/jsf-vanilla",
  "version": "0.0.1-beta.1",
  "type": "module",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "require": "./dist/index.cjs",
      "default": "./dist/index.js"
    }
  },
  "main": "dist/index.cjs",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "sideEffects": false,
  "dependencies": {
    "@ianhunterpersonal/jsf-core": "0.0.1-beta.1"
  },
  "devDependencies": {
    "tsup": "^8.5.0",
    "typescript": "^5.5.4"
  },
  "scripts": {
    "build": "tsup src/index.ts --dts --format esm,cjs --clean && tsup src/browser.ts --format iife --global-name JSFVanilla --out-dir dist",
    "test": "echo 'no tests'"
  }
}
=======
packages/jsf-vanilla/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "module": "ESNext",
    "moduleResolution": "Bundler"
  },
  "include": [
    "src"
  ]
}=======
packages/jsf-vanilla/src/browser.ts
export { renderJsonSchemaForm } from "./index";
=======
packages/jsf-vanilla/src/index.ts
// Vanilla adapter with const options + focus-preserving, debounced rerenders
import { createEngine, getByPath, sanitizeId } from "@ianhunterpersonal/jsf-core";
import type { JSONSchema, ValidationError } from "@ianhunterpersonal/jsf-core";

type ValidateCtx = { valid: boolean; errors: ValidationError[]; data: any; ts: number };
type ChangeCtx = { path: string; value: any; data: any; schema: JSONSchema; ts: number };

type ConstVisibility = "hidden" | "readonly" | "visible";
type ConstErrorStrategy = "suppress-when-managed" | "show";

export type VanillaOptions = {
  nativeRequiredMode?: 'off' | 'semantics' | 'enforce';
  oneOfBranchTitleVisibility?: 'sr-only' | 'hidden' | 'visible';
  oneOfBranchShowDescription?: boolean;
  schema: JSONSchema;
  initialData?: any;
  classNamePrefix?: string;
  debug?: boolean;
  debounceMs?: number;
  keepDataOnOneOfSwitch?: boolean;

  constVisibility?: ConstVisibility;           // default 'hidden'
  autoConstTagging?: boolean;                  // default true
  constErrorStrategy?: ConstErrorStrategy;     // default 'suppress-when-managed'

  onChange?: (data: any) => void;
  onSubmit?: (data: any) => void;
  onSubmitFailed?: (ctx: ValidateCtx) => void;
  onValidate?: (ctx: ValidateCtx) => void;
  onBeforeChange?: (ctx: ChangeCtx) => boolean | void;
  onAfterChange?: (ctx: ChangeCtx) => void;
  onBeforeSubmit?: (ctx: ValidateCtx) => boolean | void;
  onBranchChange?: (info: { path: string; index: number }) => void;
  onArrayAdd?: (info: { path: string; index: number }) => void;
  onArrayRemove?: (info: { path: string; index: number }) => void;
  onReset?: (data: any) => void;
  onSchemaLoad?: (schema: JSONSchema) => void;
  transformError?: (e: ValidationError) => ValidationError | null;
};

export type VanillaHandle = {
  getData(): any;
  setData(data: any): void;
  validate(): boolean;
  reset(data?: any): void;
  destroy(): void;
};

function debounce<T extends (...a:any[])=>void>(ms:number, fn:T):T{
  let t:any=null; // eslint-disable-line
  return function(this:any, ...args:any[]){ // eslint-disable-line
    if (t) clearTimeout(t);
    t = setTimeout(()=>{ t=null; fn.apply(this,args); }, ms);
  } as T;
}

// Apply all direct property const tags for a chosen branch schema at a given path.
function applyConstTagsForBranch(engine: any, path: string, branchSchema: any, enable:boolean) {
  if (!enable) return;
  const props = branchSchema?.properties || {};
  for (const k of Object.keys(props)) {
    const sub: any = (props as any)[k];
    if (sub && typeof sub === "object" && Object.prototype.hasOwnProperty.call(sub, "const")) {
      const p = path ? `${path}.${k}` : k;
      engine.setValue(p, sub.const);
    }
  }
}

export function renderJsonSchemaForm(target: HTMLElement | string, opts: VanillaOptions): VanillaHandle {
  const mount: HTMLElement = typeof target === "string" ? (document.querySelector(target) as HTMLElement) : target;
  if (!mount) throw new Error("Mount element not found");

  const {
    schema,
    initialData,
    classNamePrefix = "jsf-",
    debug = false,
    debounceMs = 120,
    keepDataOnOneOfSwitch,
    constVisibility = "hidden",
    autoConstTagging = true,
    constErrorStrategy = "suppress-when-managed",
    onChange,
    onSubmit,
    onSubmitFailed,
    onValidate,
    onBeforeChange,
    onAfterChange,
    onBeforeSubmit,
    onBranchChange,
    onArrayAdd,
    onArrayRemove,
    onReset,
    onSchemaLoad,
    transformError
  ,
    oneOfBranchTitleVisibility = 'sr-only',
    oneOfBranchShowDescription = true,
    nativeRequiredMode = 'semantics'} = opts;

  const engine = createEngine(schema, initialData, { keepDataOnOneOfSwitch });
  onSchemaLoad?.(schema);

  const prefix = (c: string) => classNamePrefix + c;
  const constPaths: Set<string> = new Set();

  const dispatch = (name: string, detail: any, cancelable=false) => {
    const ev = new CustomEvent(name, { bubbles: true, cancelable, detail });
    mount.dispatchEvent(ev);
    return ev.defaultPrevented;
  };

  // --- Focus-preserving rerender helpers ------------------------------------
  function captureFocus(){
    const ae = document.activeElement as (HTMLElement|null);
    const id = (ae && ae.id) ? ae.id : null;
    let sel: {start:number|null; end:number|null} | null = null;
    if (ae && (ae as HTMLInputElement).selectionStart !== undefined) {
      const inp = ae as HTMLInputElement;
      sel = { start: inp.selectionStart, end: inp.selectionEnd };
    }
    return { id, sel };
  }
  function restoreFocus(id: string|null, sel: {start:number|null; end:number|null} | null){
    if (!id) return;
    const el = document.getElementById(id) as (HTMLInputElement|null);
    if (!el) return;
    el.focus();
    if (sel && sel.start != null && sel.end != null && typeof el.setSelectionRange === "function") {
      try { el.setSelectionRange(sel.start, sel.end); } catch {}
    }
  }
  function rerenderPreserveFocus(){
    const { id, sel } = captureFocus();
    mount.innerHTML = "";
    mount.appendChild(buildForm());
    restoreFocus(id, sel);
  }
  // --------------------------------------------------------------------------

  const runValidate = () => {
    const ok = engine.validate() as boolean;
    const st = engine.getState();
    let errs: ValidationError[] = st.errors;
    if (transformError) errs = (errs.map(transformError).filter(Boolean) as ValidationError[]);

    // Filter summary 'oneOf' error when a branch is selected at that path
    { const active = (st as any).activeOneOf || {};
      errs = errs.filter(e => !(e.keyword === "oneOf" && Object.prototype.hasOwnProperty.call(active, e.path)));
    }
    if (constErrorStrategy === "suppress-when-managed") {
      errs = errs.filter(e => !(e.keyword === "const" && constPaths.has(e.path)));
    }
    const ctx: ValidateCtx = { valid: ok, errors: errs, data: st.data, ts: Date.now() };
    onValidate?.(ctx);
    dispatch("jsf-validate", ctx);
    return ctx;
  };

  // Debounced pipeline: validate → rerender (preserving focus) → fire onChange
  const debouncedAfterChange = debounce(Math.max(150, debounceMs), () => {
    const _ = runValidate();
    rerenderPreserveFocus();
    onChange?.(engine.getState().data);
  });

  const el = (tag: string, cls?: string) => {
    const e = document.createElement(tag);
    if (cls) e.className = cls;
    return e;
  };

  const fieldError = (path: string, errs: ValidationError[]) => errs.find(e => e.path === path);

  const applyChange = (path: string, value: any) => {
    const st0 = engine.getState();
    const ctx0: ChangeCtx = { path, value, data: st0.data, schema, ts: Date.now() };
    let vetoed = false;
    if (onBeforeChange) { const r = onBeforeChange(ctx0); if (r === false) vetoed = true; }
    if (dispatch("jsf-before-change", ctx0, true)) vetoed = true;
    if (vetoed) return;

    engine.setValue(path, value);

    const st1 = engine.getState();
    const ctx1: ChangeCtx = { path, value, data: st1.data, schema, ts: Date.now() };
    onAfterChange?.(ctx1);
    mount.dispatchEvent(new CustomEvent("jsf-change", { bubbles: true, detail: ctx1 }));

    // Do NOT hard-rerender immediately (keeps typing smooth).
    debouncedAfterChange();
  };

  const addItem = (path: string) => {
    engine.addArrayItem(path);
    const arr = getByPath(engine.getState().data, path);
    const idx = (Array.isArray(arr) ? arr.length : 1) - 1;
    onArrayAdd?.({ path, index: idx });
    mount.dispatchEvent(new CustomEvent("jsf-array-add", { bubbles: true, detail: { path, index: idx, ts: Date.now() } }));
    rerenderPreserveFocus();
    debouncedAfterChange();
  };

  const removeItem = (path: string, i: number) => {
    engine.removeArrayItem(path, i);
    onArrayRemove?.({ path, index: i });
    mount.dispatchEvent(new CustomEvent("jsf-array-remove", { bubbles: true, detail: { path, index: i, ts: Date.now() } }));
    rerenderPreserveFocus();
    debouncedAfterChange();
  };

  const setBranch = (path: string, index: number, branchSchema: any) => {
    engine.setActiveBranch(path, index);
    applyConstTagsForBranch(engine, path, branchSchema, autoConstTagging);
    onBranchChange?.({ path, index });
    mount.dispatchEvent(new CustomEvent("jsf-branch", { bubbles: true, detail: { path, index, ts: Date.now() } }));
    rerenderPreserveFocus();
    debouncedAfterChange();
  };

  const renderField = (s: any, path: string, required: boolean, errs: ValidationError[], inOneOfBranch: boolean = false): HTMLElement | null => {
    const id = sanitizeId(path);
    const t = Array.isArray(s?.type) ? s.type.find((x: any) => x !== "null") : s?.type;
    const title = (s?.title ?? (path ? path.split(".").slice(-1)[0] : "field")) || "field";
    const err = fieldError(path, errs);
    const wrap = el("div", `${prefix("field")} ${err ? "is-error" : ""}`.trim());
    wrap.setAttribute("data-field-name", path);
    wrap.setAttribute("data-field-type", String(t ?? "unknown"));

    // const field handling
    if (s && typeof s === "object" && Object.prototype.hasOwnProperty.call(s, "const")) {
      constPaths.add(path);
      if (autoConstTagging) engine.setValue(path, s.const);
      const display = typeof s.const === "string" ? s.const : JSON.stringify(s.const);
      if (constVisibility === "hidden") return null;

      const lab = el("label", prefix("label"));
      lab.setAttribute("for", id);
      lab.textContent = title + (required ? " *" : "");
      wrap.appendChild(lab);

      if (constVisibility === "readonly") {
        const val = el("div", prefix("input"));
        val.id = id; (val as any).style = "opacity:.8";
        val.textContent = display;
        wrap.appendChild(val);
      } else { // visible
        const inp = el("input", prefix("input")) as HTMLInputElement;
        inp.id = id; inp.value = display; inp.disabled = true; inp.setAttribute("aria-readonly","true");
        
      }

      if (err) {
        const em = el("div", prefix("error"));
        em.id = id + "-err";
        em.textContent = err.message;
        wrap.appendChild(em);
      }
      return wrap;
    }

    // oneOf / anyOf
    if (Array.isArray(s?.oneOf) || Array.isArray(s?.anyOf)) {
      const group = s.oneOf || s.anyOf;
      const idx = (engine.getState().activeOneOf || {})[path] ?? 0;

      const lab = el("label", prefix("label"));
      lab.setAttribute("for", id);
      lab.textContent = title + (required ? " *" : "");
      wrap.appendChild(lab);

      const sel = el("select", prefix("select")) as HTMLSelectElement;
      sel.id = id;
      group.forEach((g: any, i: number) => {
        const opt = el("option") as HTMLOptionElement;
        opt.value = String(i);
        opt.textContent = g.title ?? `${title} (${i + 1})`;
        if (i === idx) opt.selected = true;
        sel.appendChild(opt);
      });
      sel.addEventListener("change", () => setBranch(path, Number(sel.value), group[Number(sel.value)]));
      if (required && nativeRequiredMode !== 'off') { sel.required = true; sel.setAttribute('aria-required', 'true'); }
      wrap.appendChild(sel);

      applyConstTagsForBranch(engine, path, group[idx], autoConstTagging);
      if (oneOfBranchShowDescription && (group[idx] as any)?.description) {
        const hint = el("div", prefix("hint"));
        hint.style.opacity = ".85"; hint.style.fontSize = "0.9em"; hint.style.marginTop = "4px";
        hint.textContent = (group[idx] as any).description;
        wrap.appendChild(hint);
      }

      
const inner = renderField(group[idx], path, required, errs, true);
// Enforce oneOf branch legend visibility after render (robust even if flags weren't applied earlier)
if (inner && inner.tagName === "FIELDSET") {
  inner.setAttribute("data-oneof-branch", "true");
  const leg = inner.querySelector("legend");
  if (leg) {
    if (oneOfBranchTitleVisibility === 'hidden') {
      leg.remove();
    } else if (oneOfBranchTitleVisibility === 'sr-only') {
      // robust SR-only styles
      leg.style.position = "absolute";
      leg.style.width = "1px";
      leg.style.height = "1px";
      leg.style.padding = "0";
      leg.style.margin = "-1px";
      leg.style.overflow = "hidden";
      leg.style.whiteSpace = "nowrap";
      leg.style.borderWidth = "0";
      leg.style.clip = "rect(0,0,0,0)";
      leg.style.clipPath = "inset(50%)";
      leg.style.left = "-9999px";
    }
  }
}
      if (inner) {
        const box = el("div", prefix("object"));
        box.appendChild(inner);
        wrap.appendChild(box);
      }
      if (err) {
        const em = el("div", prefix("error"));
        em.id = id + "-err";
        em.textContent = err.message;
        wrap.appendChild(em);
      }
      return wrap;
    }

    // Enum
    if (Array.isArray(s?.enum)) {
      const value = getByPath(engine.getState().data, path);
      const strValue = typeof value === "string" ? value : (value == null ? "" : JSON.stringify(value));
      const labels: string[] = (s["x-enumNames"] || s["x-enum-labels"] || s.enum).map((x: any) => String(x));

      const lab = el("label", prefix("label"));
      lab.setAttribute("for", id);
      lab.textContent = title + (required ? " *" : "");
      wrap.appendChild(lab);

      const sel = el("select", prefix("select")) as HTMLSelectElement;
      sel.id = id;
      const blank = el("option") as HTMLOptionElement;
      blank.value = ""; blank.textContent = "-- select --";
      sel.appendChild(blank);
      s.enum.forEach((v: any, i: number) => {
        const opt = el("option") as HTMLOptionElement;
        opt.value = typeof v === "string" ? v : JSON.stringify(v);
        opt.textContent = labels[i];
        if (opt.value === strValue) opt.selected = true;
        sel.appendChild(opt);
      });
      sel.addEventListener("change", () => {
        let v: any = sel.value;
        if (s.enum.some((x: any) => typeof x !== "string")) { try { v = JSON.parse(v); } catch {} }
        applyChange(path, v);
      });
      wrap.appendChild(sel);

      if (err) {
        const em = el("div", prefix("error"));
        em.id = id + "-err";
        em.textContent = err.message;
        wrap.appendChild(em);
      }
      return wrap;
    }

    // Object (+ additionalProperties)
    if (t === "object" || s.properties) {
      const req: string[] = s.required || [];
      const obj = el("fieldset", `${prefix("object")} ${prefix("field")} ${err ? "is-error" : ""}`.trim());
      obj.setAttribute("data-field-name", path);
      obj.setAttribute("data-field-type", "object");

      const leg = el("legend", prefix("label"));
      leg.textContent = title + (required ? " *" : "");
      obj.appendChild(leg);

      Object.entries(s.properties || {}).forEach(([k, sub]) => {
        const child = renderField(sub as any, path ? `${path}.${k}` : k, req.includes(k), errs);
        if (child) obj.appendChild(child);
      });

      const additionalSchema = s.additionalProperties && typeof s.additionalProperties === "object" ? s.additionalProperties : null;
      if (additionalSchema) {
        const stateObj = getByPath(engine.getState().data, path) || {};
        const extraKeys = Object.keys(stateObj).filter(k => !(s.properties || {})[k]);

        const strong = el("strong"); strong.textContent = "Additional properties"; obj.appendChild(strong);

        extraKeys.forEach((k) => {
          const row = el("div");
          row.style.display = "grid"; (row.style as any).gridTemplateColumns = "1fr auto"; row.style.gap = "8px";
          const field = renderField(additionalSchema, path ? `${path}.${k}` : k, false, errs);
          if (field) row.appendChild(field);
          const btn = el("button") as HTMLButtonElement; btn.type="button"; btn.textContent="Remove";
          btn.onclick = () => {
            const next = { ...engine.getState().data };
            const segs = path ? path.split(".") : [];
            let cur:any = next; for (const seg of segs) { cur[seg] = cur[seg] ?? {}; cur = cur[seg]; }
            delete cur[k];
            engine.reset(next);
            rerenderPreserveFocus(); debouncedAfterChange();
          };
          row.appendChild(btn);
          obj.appendChild(row);
        });

        const addRow = el("div"); addRow.style.display="flex"; addRow.style.gap="8px"; addRow.style.marginTop="8px";
        const keyInput = el("input", prefix("input")) as HTMLInputElement; keyInput.placeholder = "new key";
        const addBtn = el("button") as HTMLButtonElement; addBtn.type="button"; addBtn.textContent="Add";
        addBtn.onclick = () => {
          const name = (keyInput.value||"").trim(); if (!name) return;
          const next = { ...engine.getState().data };
          const segs = path ? path.split(".") : [];
          let cur:any = next; for (const seg of segs) { cur[seg] = cur[seg] ?? {}; cur = cur[seg]; }
          if (cur[name] !== undefined) return;
          cur[name] = undefined;
          engine.reset(next);
          keyInput.value = "";
          rerenderPreserveFocus(); debouncedAfterChange();
        };
        addRow.appendChild(keyInput); addRow.appendChild(addBtn);
        obj.appendChild(addRow);
      }

      if (err) {
        const em = el("div", prefix("error"));
        em.id = id + "-err";
        em.textContent = err.message;
        obj.appendChild(em);
      }

      return obj;
    }

    // Array
    if (t === "array" || s.items) {
      const arrWrap = el("div", `${prefix("field")} ${err ? "is-error" : ""}`.trim());
      arrWrap.setAttribute("data-field-name", path);
      arrWrap.setAttribute("data-field-type", "array");

      const lab = el("label", prefix("label"));
      lab.setAttribute("for", id);
      lab.textContent = title + (required ? " *" : "");
      arrWrap.appendChild(lab);

      const items = Array.isArray(getByPath(engine.getState().data, path)) ? getByPath(engine.getState().data, path) : [];
      items.forEach((_v: any, i: number) => {
        const row = el("div");
        row.style.marginBottom = "8px";
        const child = renderField(s.items, `${path}.${i}`, false, errs);
        if (child) row.appendChild(child);
        const btn = el("button") as HTMLButtonElement; btn.type="button"; btn.textContent="Remove";
        btn.onclick = () => removeItem(path, i);
        row.appendChild(btn);
        arrWrap.appendChild(row);
      });

      const add = el("button") as HTMLButtonElement; add.type="button"; add.textContent="Add";
      add.onclick = () => addItem(path);
      arrWrap.appendChild(add);

      if (err) {
        const em = el("div", prefix("error"));
        em.id = id + "-err";
        em.textContent = err.message;
        arrWrap.appendChild(em);
      }
      return arrWrap;
    }

    // Primitive
    const format = s.format;
    let inputType: string = "text";
    if (format === "date") inputType = "date";
    else if (format === "time") inputType = "time";
    else if (format === "date-time") inputType = "datetime-local";
    else if (format === "email") inputType = "email";
    else if (format === "uri") inputType = "url";
    else if (format === "password") inputType = "password";
    else if (t === "number" || t === "integer") inputType = "number";
    else if (t === "boolean") inputType = "checkbox";

    const value = getByPath(engine.getState().data, path);

    const lab = el("label", prefix("label"));
    lab.setAttribute("for", id);
    lab.textContent = title + (required ? " *" : "");
    wrap.appendChild(lab);

    if (inputType === "checkbox") {
      const inp = el("input", prefix("input")) as HTMLInputElement;
      inp.type = "checkbox"; inp.id = id; inp.checked = !!value;
      inp.onchange = () => applyChange(path, inp.checked);
      if (required && nativeRequiredMode !== 'off') { inp.required = true; inp.setAttribute('aria-required','true'); }
      wrap.appendChild(inp);
    } else {
      const inp = el("input", prefix("input")) as HTMLInputElement;
      inp.type = inputType; inp.id = id; inp.value = value ?? "";
      inp.oninput = () => {
        const raw = inp.value;
        let v:any = raw;
        if (t === "number" || t === "integer") v = raw === "" ? undefined : Number(raw);
        applyChange(path, v);
      };
      wrap.appendChild(inp);
    }

    if (err) {
      const em = el("div", prefix("error"));
      em.id = id + "-err";
      em.textContent = err.message;
      wrap.appendChild(em);
    }
    return wrap;
  };

  const buildForm = (): HTMLFormElement => {
    // reset const path set each render
    constPaths.clear();

    const form = el("form", prefix("form")) as HTMLFormElement;
    form.noValidate = nativeRequiredMode !== 'enforce';
    const ctx = runValidate();
    const req: string[] = (schema as any).required || [];

    let rootField: HTMLElement | null = null;
    if ((schema as any).type === "object" || (schema as any).properties) {
      const container = el("div");
      Object.entries((schema as any).properties || {}).forEach(([k, s]) => {
        const node = renderField(s as any, k, req.includes(k), ctx.errors);
        if (node) container.appendChild(node);
      });
      rootField = container;
    } else {
      rootField = renderField(schema as any, "", false, ctx.errors);
    }
    if (rootField) form.appendChild(rootField);

    const actions = el("div");
    actions.style.marginTop = "12px"; actions.style.display = "flex"; actions.style.gap = "8px";
    const submit = el("button") as HTMLButtonElement; submit.type="submit"; submit.textContent="Submit";
    const reset = el("button") as HTMLButtonElement; reset.type="button"; reset.textContent="Reset";
    actions.appendChild(submit); actions.appendChild(reset);
    form.appendChild(actions);

    form.onsubmit = (e) => {
      e.preventDefault();
      if (nativeRequiredMode === 'enforce' && typeof (form as any).reportValidity === 'function') {
        if (!(form as any).reportValidity()) { return; }
      }
      const ctx2 = runValidate();
      if (!ctx2.valid) {
        onSubmitFailed?.(ctx2);
        mount.dispatchEvent(new CustomEvent("jsf-submit-failed", { bubbles: true, detail: ctx2 }));
        if (ctx2.errors[0]) {
          const id = sanitizeId(ctx2.errors[0].path);
          document.getElementById(id)?.focus?.();
        }
        return;
      }
      const cancel = onBeforeSubmit?.(ctx2) === false || dispatch("jsf-submit", { data: ctx2.data, ts: Date.now() }, true);
      if (cancel) return;
      onSubmit?.(ctx2.data);
      if (debug) alert(JSON.stringify(ctx2.data, null, 2));
    };

    reset.onclick = () => {
      engine.reset();
      onReset?.(engine.getState().data);
      mount.dispatchEvent(new CustomEvent("jsf-reset", { bubbles: true, detail: { data: engine.getState().data, ts: Date.now() } }));
      rerenderPreserveFocus();
      debouncedAfterChange();
    };

    return form;
  };

  // Initial render
  mount.innerHTML = "";
  mount.appendChild(buildForm());

  return {
    getData(){ return engine.getState().data; },
    setData(data:any){ engine.reset(data); rerenderPreserveFocus(); runValidate(); },
    validate(){ return engine.validate() as boolean; },
    reset(data?:any){ engine.reset(data); rerenderPreserveFocus(); runValidate(); },
    destroy(){ mount.innerHTML = ""; }
  };
}

export default { renderJsonSchemaForm };
=======
packages/jsf-react/src/index.tsx
// React adapter with const visibility/tagging options
import React, { useEffect, useMemo, useRef, useState } from "react";
import { createEngine, getByPath, sanitizeId } from "@ianhunterpersonal/jsf-core";
import type { JSONSchema, ValidationError } from "@ianhunterpersonal/jsf-core";

type ChangeCtx = {
  path: string;
  value: any;
  data: any;
  schema: JSONSchema;
  ts: number;
};
type ValidateCtx = {
  valid: boolean;
  errors: ValidationError[];
  data: any;
  ts: number;
};

type ConstVisibility = "hidden" | "readonly" | "visible";
type ConstErrorStrategy = "suppress-when-managed" | "show";

export type JsonSchemaFormProps = {
  oneOfBranchTitleVisibility?: "sr-only" | "hidden" | "visible";
  oneOfBranchShowDescription?: boolean;
  schema: JSONSchema;
  initialData?: any;
  classNamePrefix?: string;
  keepDataOnOneOfSwitch?: boolean;
  debounceMs?: number;
  debug?: boolean;

  // const/discriminator options
  constVisibility?: ConstVisibility; // default 'hidden'
  autoConstTagging?: boolean; // default true
  constErrorStrategy?: ConstErrorStrategy; // default 'suppress-when-managed'

  // existing callbacks
  onChange?: (data: any) => void;
  onSubmit?: (data: any) => void | Promise<void>;
  onValidate?: (ctx: ValidateCtx) => void | Promise<void>;
  onSubmitFailed?: (ctx: ValidateCtx) => void | Promise<void>;
  transformError?: (e: ValidationError) => ValidationError | null;

  onBeforeChange?: (ctx: ChangeCtx) => boolean | void | Promise<boolean | void>;
  onAfterChange?: (ctx: ChangeCtx) => void | Promise<void>;
  onBeforeSubmit?: (
    ctx: ValidateCtx
  ) => boolean | void | Promise<boolean | void>;
  onBranchChange?: (info: {
    path: string;
    index: number;
    schema: any;
  }) => void | Promise<void>;
  onArrayAdd?: (info: { path: string; index: number }) => void | Promise<void>;
  onArrayRemove?: (info: {
    path: string;
    index: number;
  }) => void | Promise<void>;
  onReset?: (data: any) => void | Promise<void>;
  onSchemaLoad?: (schema: JSONSchema) => void | Promise<void>;
  showReset?: boolean;
};

function useDebounced(ms: number = 120) {
  const t = useRef<number | null>(null);
  const schedule = (fn: () => void) => {
    if (t.current) clearTimeout(t.current);
    t.current = window.setTimeout(() => {
      t.current = null;
      fn();
    }, ms);
  };
  useEffect(
    () => () => {
      if (t.current) clearTimeout(t.current);
    },
    []
  );
  return schedule;
}

function applyConstTagsForBranch(
  engine: any,
  path: string,
  branchSchema: any,
  enable: boolean
) {
  if (!enable) return;
  const props = branchSchema?.properties || {};
  for (const k of Object.keys(props)) {
    const sub: any = (props as any)[k];
    if (
      sub &&
      typeof sub === "object" &&
      Object.prototype.hasOwnProperty.call(sub, "const")
    ) {
      const p = path ? `${path}.${k}` : k;
      engine.setValue(p, sub.const);
    }
  }
}

// Walk schema via dot path through properties (best-effort for oneOf containers)
function getSchemaAtPath(root: any, path: string): any {
  if (!path) return root;
  const segs = path.split(".");
  let cur: any = root;
  for (const seg of segs) {
    if (!cur || typeof cur !== "object") return undefined;
    if (cur.properties && cur.properties[seg]) {
      cur = cur.properties[seg];
    } else {
      // unknown segment -> stop
      return cur;
    }
  }
  return cur;
}

export const JsonSchemaForm: React.FC<JsonSchemaFormProps> = ({
  schema,
  initialData,
  classNamePrefix = "jsf-",
  keepDataOnOneOfSwitch,
  debounceMs = 120,
  debug = false,
  constVisibility = "hidden",
  autoConstTagging = true,
  constErrorStrategy = "suppress-when-managed",
  onChange,
  onSubmit,
  onValidate,
  onSubmitFailed,
  transformError,
  onBeforeChange,
  onAfterChange,
  onBeforeSubmit,
  onBranchChange,
  onArrayAdd,
  onArrayRemove,
  onReset,
  onSchemaLoad,
  showReset = false,
}) => {
  const engineRef = useRef(
    createEngine(schema, initialData, { keepDataOnOneOfSwitch })
  );
  const [tick, setTick] = useState(0);
  const schedule = useDebounced(debounceMs);
  const prefix = (c: string) => classNamePrefix + c;

  // Track const paths seen during render for error suppression
  const constPathsRef = useRef<Set<string>>(new Set());
  // Paths of discriminator const fields to hide (e.g. profile.kind)
  const hiddenConstPathsRef = useRef<Set<string>>(new Set());
  const resetConstPaths = () => {
    constPathsRef.current = new Set();
  };

  useEffect(() => {
    engineRef.current.setSchema(schema);
    setTick((x) => x + 1);
    (async () => {
      if (onSchemaLoad) await onSchemaLoad(schema);
    })();
  }, [schema, onSchemaLoad]);

  const firstMount = useRef(true);
  useEffect(() => {
    if (firstMount.current && initialData !== undefined) {
      engineRef.current.reset(initialData);
      firstMount.current = false;
    }
  }, [initialData]);

  // After each tick, ensure current active oneOf/anyOf branch const tags are applied.
  useEffect(() => {
    const st = engineRef.current.getState() as any;
    const active: Record<string, number> = st.activeOneOf || {};
    for (const path of Object.keys(active)) {
      const idx = active[path] ?? 0;
      const at = getSchemaAtPath(schema, path);
      const group = at?.oneOf || at?.anyOf;
      if (Array.isArray(group)) {
        applyConstTagsForBranch(
          engineRef.current,
          path,
          group[idx],
          autoConstTagging
        );
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tick, schema, autoConstTagging]);

  const runPostChange = () => {
    schedule(async () => {
      const ok = engineRef.current.validate() as boolean;
      const st = engineRef.current.getState();
      let errs: ValidationError[] = st.errors;
      if (transformError)
        errs = errs.map(transformError).filter(Boolean) as ValidationError[];
      if (constErrorStrategy === "suppress-when-managed") {
        errs = errs.filter(
          (e) => !(e.keyword === "const" && constPathsRef.current.has(e.path))
        );
      }
      const ctx: ValidateCtx = {
        valid: ok,
        errors: errs,
        data: st.data,
        ts: Date.now(),
      };
      if (onChange) onChange(st.data);
      if (onValidate) await onValidate(ctx);
      setTick((x) => x + 1);
    });
  };

  const applyChange = async (path: string, value: any) => {
    const st0 = engineRef.current.getState();
    const ctx0: ChangeCtx = {
      path,
      value,
      data: st0.data,
      schema,
      ts: Date.now(),
    };
    if (onBeforeChange) {
      const res = await onBeforeChange(ctx0);
      if (res === false) return;
    }
    engineRef.current.setValue(path, value);
    const st1 = engineRef.current.getState();
    const ctx1: ChangeCtx = {
      path,
      value,
      data: st1.data,
      schema,
      ts: Date.now(),
    };
    if (onAfterChange) await onAfterChange(ctx1);
    setTick((x) => x + 1);
    runPostChange();
  };

  const addItem = async (path: string) => {
    engineRef.current.addArrayItem(path);
    const arr = getByPath(engineRef.current.getState().data, path);
    const index = (Array.isArray(arr) ? arr.length : 1) - 1;
    if (onArrayAdd) await onArrayAdd({ path, index });
    setTick((x) => x + 1);
    runPostChange();
  };

  const removeItem = async (path: string, i: number) => {
    engineRef.current.removeArrayItem(path, i);
    if (onArrayRemove) await onArrayRemove({ path, index: i });
    setTick((x) => x + 1);
    runPostChange();
  };

  const setBranch = async (path: string, index: number, branchSchema: any) => {
    engineRef.current.setActiveBranch(path, index);
    applyConstTagsForBranch(
      engineRef.current,
      path,
      branchSchema,
      autoConstTagging
    );
    if (onBranchChange)
      await onBranchChange({ path, index, schema: branchSchema });
    setTick((x) => x + 1);
    runPostChange();
  };

  const state = engineRef.current.getState();

  const errors: ValidationError[] = useMemo(() => {
    let errs: ValidationError[] = state.errors as ValidationError[];

    if (transformError) {
      errs = errs
        .map(transformError)
        .filter((x): x is ValidationError => Boolean(x));
    }

    // suppress summary oneOf error when a branch is active at that path
    const active = (state as any).activeOneOf || {};
    errs = errs.filter(
      (e: ValidationError) =>
        !(
          e.keyword === "oneOf" &&
          Object.prototype.hasOwnProperty.call(active, e.path)
        )
    );

    if (constErrorStrategy === "suppress-when-managed") {
      errs = errs.filter(
        (e: ValidationError) =>
          !(e.keyword === "const" && constPathsRef.current.has(e.path))
      );
    }

    return errs;
  }, [tick, transformError, constErrorStrategy]);

  const handleSubmit: React.FormEventHandler<HTMLFormElement> = async (
    e: React.FormEvent<HTMLFormElement>
  ) => {
    e.preventDefault();
    const ok = engineRef.current.validate() as boolean;
    const st = engineRef.current.getState();
    let errs: ValidationError[] = st.errors;
    if (transformError)
      errs = errs.map(transformError).filter(Boolean) as ValidationError[];
    if (constErrorStrategy === "suppress-when-managed") {
      errs = errs.filter(
        (er) => !(er.keyword === "const" && constPathsRef.current.has(er.path))
      );
    }
    const ctx: ValidateCtx = {
      valid: ok,
      errors: errs,
      data: st.data,
      ts: Date.now(),
    };

    if (!ok) {
      if (onValidate) await onValidate(ctx);
      if (onSubmitFailed) await onSubmitFailed(ctx);
      if (errs[0]) {
        const id = sanitizeId(errs[0].path);
        document.getElementById(id)?.focus?.();
      }
      setTick((x) => x + 1);
      return;
    }
    if (onValidate) await onValidate(ctx);
    if (onBeforeSubmit) {
      const proceed = await onBeforeSubmit(ctx);
      if (proceed === false) return;
    }
    if (onSubmit) await onSubmit(st.data);
    if (debug) alert(JSON.stringify(st.data, null, 2));
  };

  const fieldError = (path: string) => errors.find((e) => e.path === path);

  // ---------- PURE RENDER FUNCTION (not a component) ----------
  type RFProps = { schema: any; path: string; required: boolean };
  const renderField = ({
    schema: s,
    path,
    required,
  }: RFProps): JSX.Element | null => {
    const t = Array.isArray(s?.type)
      ? s.type.find((x: any) => x !== "null")
      : s?.type;
    const id = sanitizeId(path);
    const title =
      (s?.title ?? (path ? path.split(".").slice(-1)[0] : "field")) || "field";
    const err = fieldError(path);
    const wrapCls = [prefix("field"), err ? "is-error" : ""]
      .filter(Boolean)
      .join(" ");

    // Handle const fields
    if (
      s &&
      typeof s === "object" &&
      Object.prototype.hasOwnProperty.call(s, "const")
    ) {
      // Hide discriminator consts that are registered for this path
      if (hiddenConstPathsRef.current.has(path)) {
        if (autoConstTagging) (engineRef.current as any).setValue(path, (s as any).const);
        return null;
      }
      constPathsRef.current.add(path);
      if (autoConstTagging) engineRef.current.setValue(path, s.const);
      const display =
        typeof s.const === "string" ? s.const : JSON.stringify(s.const);
      if (constVisibility === "hidden") return null;
      if (constVisibility === "readonly") {
        return (
          <div
            className={wrapCls}
            data-field-name={path}
            data-field-type={"const"}
          >
            <label className={prefix("label")} htmlFor={id}>
              {title}
              {required ? " *" : ""}
            </label>
            <div
              className={prefix("input")}
              id={id}
              aria-readonly="true"
              style={{ opacity: 0.8 }}
            >
              {display}
            </div>
            {err && (
              <div className={prefix("error")} id={id + "-err"}>
                {err.message}
              </div>
            )}
          </div>
        );
      }
      // visible: disabled input
      return (
        <div
          className={wrapCls}
          data-field-name={path}
          data-field-type={"const"}
        >
          <label className={prefix("label")} htmlFor={id}>
            {title}
            {required ? " *" : ""}
          </label>
          <input
            className={prefix("input")}
            id={id}
            value={display}
            disabled
            aria-readonly="true"
          />
          {err && (
            <div className={prefix("error")} id={id + "-err"}>
              {err.message}
            </div>
          )}
        </div>
      );
    }

    // oneOf / anyOf
    if (Array.isArray(s?.oneOf) || Array.isArray(s?.anyOf)) {
      const group = s.oneOf || s.anyOf;
      const idx = state.activeOneOf[path] ?? 0;

      // Discriminator property name on the selector schema (if any)
      const discProp = typeof (s as any)?.discriminator?.propertyName === "string"
        ? (s as any).discriminator.propertyName
        : null;
      if (discProp) {
        // e.g. path="profile" + ".kind" → hide that const field in the branch UI
        hiddenConstPathsRef.current.add(path ? `${path}.${discProp}` : discProp);
      }

      return (
        <div
          className={wrapCls}
          data-field-name={path}
          data-field-type={"oneOf"}
        >
          <label className={prefix("label")} htmlFor={id}>
            {title}
            {required ? " *" : ""}
          </label>
          <select
            id={id}
            className={prefix("select")}
            value={String(idx)}
            onChange={(e: React.ChangeEvent<HTMLSelectElement>) =>
              setBranch(
                path,
                Number(e.target.value),
                group[Number(e.target.value)]
              )
            }
          >
            {group.map((g: any, i: number) => (
              <option key={i} value={String(i)}>
                {g.title ?? `${title} (${i + 1})`}
              </option>
            ))}
          </select>
          <div className={prefix("object")}>
            {renderField({ schema: group[idx], path, required })}
          </div>
          {err && (
            <div className={prefix("error")} id={id + "-err"}>
              {err.message}
            </div>
          )}
        </div>
      );
    }

    // Enum
    if (Array.isArray(s?.enum)) {
      const value = getByPath(state.data, path);
      const strValue =
        typeof value === "string"
          ? value
          : value == null
          ? ""
          : JSON.stringify(value);
      const labels: string[] = (
        s["x-enumNames"] ||
        s["x-enum-labels"] ||
        s.enum
      ).map((x: any) => String(x));
      return (
        <div
          className={wrapCls}
          data-field-name={path}
          data-field-type={"enum"}
        >
          <label className={prefix("label")} htmlFor={id}>
            {title}
            {required ? " *" : ""}
          </label>
          <select
            id={id}
            className={prefix("select")}
            value={strValue}
            onChange={(e: React.ChangeEvent<HTMLSelectElement>) => {
              let v: any = e.target.value;
              if (s.enum.some((x: any) => typeof x !== "string")) {
                try {
                  v = JSON.parse(v);
                } catch {}
              }
              applyChange(path, v);
            }}
          >
            <option value="">-- select --</option>
            {s.enum.map((v: any, i: number) => (
              <option
                key={i}
                value={typeof v === "string" ? v : JSON.stringify(v)}
              >
                {labels[i]}
              </option>
            ))}
          </select>
          {err && (
            <div className={prefix("error")} id={id + "-err"}>
              {err.message}
            </div>
          )}
        </div>
      );
    }

    // Object (+ additionalProperties)
    if (t === "object" || s.properties) {
      const req: string[] = s.required || [];
      const objVal = getByPath(state.data, path) || {};
      const additionalSchema =
        s.additionalProperties && typeof s.additionalProperties === "object"
          ? s.additionalProperties
          : null;
      const extraKeys = additionalSchema
        ? Object.keys(objVal).filter((k: string) => !(s.properties || {})[k])
        : [];

      return (
        <fieldset
          className={wrapCls + " " + prefix("object")}
          data-field-name={path}
          data-field-type={"object"}
        >
          <legend className={prefix("label")}>
            {title}
            {required ? " *" : ""}
          </legend>

          {Object.entries(s.properties || {}).map(([k, sub]) => (
            <React.Fragment key={k}>
              {renderField({
                schema: sub as any,
                path: path ? `${path}.${k}` : k,
                required: req.includes(k),
              })}
            </React.Fragment>
          ))}

          {additionalSchema && (
            <div style={{ marginTop: 6 }}>
              <strong>Additional properties</strong>
              {extraKeys.map((k) => (
                <div
                  key={k}
                  style={{
                    display: "grid",
                    gridTemplateColumns: "1fr auto",
                    gap: 8,
                    marginTop: 6,
                  }}
                >
                  {renderField({
                    schema: additionalSchema,
                    path: path ? `${path}.${k}` : k,
                    required: false,
                  })}
                  <button
                    type="button"
                    onClick={() => {
                      const next = { ...engineRef.current.getState().data };
                      const segs = path ? path.split(".") : [];
                      let cur: any = next;
                      for (const seg of segs) {
                        cur[seg] = cur[seg] ?? {};
                        cur = cur[seg];
                      }
                      delete cur[k];
                      engineRef.current.reset(next);
                      setTick((x) => x + 1);
                      runPostChange();
                    }}
                  >
                    Remove
                  </button>
                </div>
              ))}
              {renderAddKeyRow(path)}
            </div>
          )}
          {err && (
            <div className={prefix("error")} id={id + "-err"}>
              {err.message}
            </div>
          )}
        </fieldset>
      );
    }

    // Array
    if (t === "array" || s.items) {
      const items = Array.isArray(getByPath(state.data, path))
        ? getByPath(state.data, path)
        : [];
      return (
        <div
          className={wrapCls}
          data-field-name={path}
          data-field-type={"array"}
        >
          <label className={prefix("label")} htmlFor={id}>
            {title}
            {required ? " *" : ""}
          </label>
          <div>
            {items.map((_v: any, i: number) => (
              <div key={i} style={{ marginBottom: 8 }}>
                {renderField({
                  schema: s.items,
                  path: `${path}.${i}`,
                  required: false,
                })}
                <button type="button" onClick={() => removeItem(path, i)}>
                  Remove
                </button>
              </div>
            ))}
            <button type="button" onClick={() => addItem(path)}>
              Add
            </button>
          </div>
          {err && (
            <div className={prefix("error")} id={id + "-err"}>
              {err.message}
            </div>
          )}
        </div>
      );
    }

    // Primitive
    const format = s.format;
    let inputType: React.HTMLInputTypeAttribute = "text";
    if (format === "date") inputType = "date";
    else if (format === "time") inputType = "time";
    else if (format === "date-time") inputType = "datetime-local";
    else if (format === "email") inputType = "email";
    else if (format === "uri") inputType = "url";
    else if (format === "password") inputType = "password";
    else if (t === "number" || t === "integer") inputType = "number";
    else if (t === "boolean") inputType = "checkbox";

    const value = getByPath(state.data, path);
    const commonProps = {
      id,
      className: prefix("input"),
      "aria-invalid": !!err || undefined,
      "aria-describedby": err ? id + "-err" : undefined,
    } as const;

    return (
      <div
        className={wrapCls}
        data-field-name={path}
        data-field-type={String(t ?? "unknown")}
      >
        <label className={prefix("label")} htmlFor={id}>
          {title}
          {required ? " *" : ""}
        </label>
        {inputType === "checkbox" ? (
          <input
            type="checkbox"
            {...commonProps}
            checked={!!value}
            onChange={(e) => applyChange(path, e.currentTarget.checked)}
          />
        ) : (
          <input
            type={inputType}
            {...commonProps}
            value={value ?? ""}
            onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
              const raw = e.currentTarget.value;
              let v: any = raw;
              if (t === "number" || t === "integer")
                v = raw === "" ? undefined : Number(raw);
              applyChange(path, v);
            }}
          />
        )}
        {err && (
          <div className={prefix("error")} id={id + "-err"}>
            {err.message}
          </div>
        )}
      </div>
    );
  };
  // ---------- /PURE RENDER FUNCTION ----------

  // Inline row for additionalProperties key add
  const renderAddKeyRow = (path: string) => {
    const [key, setKey] = useState(""); // NOTE: local hook in render helper is not allowed; replace with controlled below
    // We cannot use hooks here (this is not a component). Implement as inline controlled inputs via a tiny inner component:
    const AddKeyRow: React.FC = () => {
      const [k, setK] = useState("");
      return (
        <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
          <input
            className={prefix("input")}
            placeholder="new key"
            value={k}
            onChange={(e) => setK(e.currentTarget.value)}
          />
          <button
            type="button"
            onClick={() => {
              const name = k.trim();
              if (!name) return;
              const next = { ...engineRef.current.getState().data };
              const segs = path ? path.split(".") : [];
              let cur: any = next;
              for (const seg of segs) {
                cur[seg] = cur[seg] ?? {};
                cur = cur[seg];
              }
              if (cur[name] !== undefined) return;
              cur[name] = undefined;
              engineRef.current.reset(next);
              setK("");
              setTick((x) => x + 1);
              runPostChange();
            }}
          >
            Add
          </button>
        </div>
      );
    };
    return <AddKeyRow />;
  };

  // reset const path tracking before each render pass
  resetConstPaths();
  hiddenConstPathsRef.current = new Set();

  const req: string[] = (schema as any).required || [];
  return (
    <form className={prefix("form")} noValidate onSubmit={handleSubmit}>
      {(schema as any).type === "object" || (schema as any).properties
        ? Object.entries((schema as any).properties || {}).map(([k, s]) => (
            <React.Fragment key={k}>
              {renderField({
                schema: s as any,
                path: k,
                required: req.includes(k),
              })}
            </React.Fragment>
          ))
        : renderField({ schema: schema as any, path: "", required: false })}

      <div style={{ marginTop: 12, display: "flex", gap: 8 }}>
        <button type="submit">Submit</button>
        {showReset && (
          <button
            type="button"
            onClick={async () => {
              engineRef.current.reset();
              setTick((x) => x + 1);
              if (onReset) await onReset(engineRef.current.getState().data);
              runPostChange();
            }}
          >
            Reset
          </button>
        )}
      </div>

      {debug && (
        <pre
          style={{
            background: "#fafafa",
            border: "1px solid #eee",
            padding: 8,
            borderRadius: 8,
            marginTop: 12,
          }}
        >
          {JSON.stringify(
            { data: engineRef.current.getState().data, errors },
            null,
            2
          )}
        </pre>
      )}
    </form>
  );
};

export default JsonSchemaForm;
=======
packages/jsf-react/src/index.css
:root {
  --jsf-error-bg: #fee2e2;
  --jsf-dirty-bg: #fff7ed;
  --jsf-label-color: #111827;
  --jsf-input-border: #d1d5db;
  --jsf-radius: 8px;
  --jsf-spacing-sm: 6px;
  --jsf-spacing-md: 10px;
  --jsf-spacing-lg: 16px;
  --jsf-font-size-sm: 0.875rem;
  --jsf-font-size-md: 1rem;
  --jsf-font-size-lg: 1.125rem;
}
.jsf-form { display:block; }
.jsf-field { margin: var(--jsf-spacing-md) 0; }
.jsf-label { display:block; margin-bottom: 4px; font-weight: 600; color: var(--jsf-label-color); }
.jsf-input, .jsf-select, .jsf-textarea {
  width: 100%;
  padding: 8px;
  border: 1px solid var(--jsf-input-border);
  border-radius: var(--jsf-radius);
  font-size: var(--jsf-font-size-md);
}
.jsf-error { color:#b91c1c; font-size: var(--jsf-font-size-sm); margin-top: 4px; }
.is-error .jsf-input, .is-error .jsf-select, .is-error .jsf-textarea { background: var(--jsf-error-bg); }
.is-dirty:not(.is-error) .jsf-input, .is-dirty:not(.is-error) .jsf-select, .is-dirty:not(.is-error) .jsf-textarea { background: var(--jsf-dirty-bg); }

/* Hide the inner object legend when rendering a selected oneOf branch.
   We keep it for screen readers (sr-only style) to preserve context. */
.jsf-field[data-field-type="oneOf"] > .jsf-object fieldset > legend {
  display: none !important;
}=======
packages/jsf-react/src/styles/theme.css
:root {
  --jsf-error-bg: #ffe6e6;
  --jsf-dirty-bg: #fff9db;
  --jsf-label-color: #333;
  --jsf-input-border: #ccc;
  --jsf-radius: 8px;
  --jsf-spacing-sm: 6px;
  --jsf-spacing-md: 10px;
  --jsf-spacing-lg: 16px;
  --jsf-font-size-sm: 12px;
  --jsf-font-size-md: 14px;
  --jsf-font-size-lg: 16px;
}
.jsf-form { font-size: var(--jsf-font-size-md); }
.jsf-field { margin-bottom: var(--jsf-spacing-lg); }
.jsf-label { color: var(--jsf-label-color); display:block; margin-bottom: var(--jsf-spacing-sm); }
.jsf-input, .jsf-select, .jsf-textarea {
  width: 100%;
  border: 1px solid var(--jsf-input-border);
  border-radius: var(--jsf-radius);
  padding: var(--jsf-spacing-sm) var(--jsf-spacing-md);
  background: white;
}
.jsf-error { color: #b00020; margin-top: 4px; font-size: var(--jsf-font-size-sm); }
.jsf-field.is-error { background: var(--jsf-error-bg); padding: var(--jsf-spacing-sm); border-radius: var(--jsf-radius); }
.jsf-field.is-dirty:not(.is-error) { background: var(--jsf-dirty-bg); padding: var(--jsf-spacing-sm); border-radius: var(--jsf-radius); }
.jsf-array-controls button { margin-right: 6px; }
=======
packages/jsf-react/package.json
{
  "name": "@ianhunterpersonal/jsf-react",
  "version": "0.0.1-beta.3",
  "type": "module",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "require": "./dist/index.cjs",
      "types": "./dist/index.d.ts"
    },
    "./styles.css": "./dist/styles.css",
    "./dist/index.css": "./dist/index.css"
  },
  "main": "dist/index.cjs",
  "module": "dist/index.js",
  "types": "dist/index.d.ts",
  "sideEffects": [
    "./dist/styles.css",
    "dist/index.css"
  ],
  "peerDependencies": {
    "react": ">=18",
    "react-dom": ">=18"
  },
  "dependencies": {
    "@ianhunterpersonal/jsf-core": "0.0.1-beta.1"
  },
  "devDependencies": {
    "tsup": "^8.5.0",
    "typescript": "^5.5.4"
  },
  "scripts": {
    "build": "tsup src/index.tsx --dts --format esm,cjs --clean && mkdir -p dist && cp src/index.css dist/index.css"
  },
  "files": [
    "dist"
  ],
  "style": "./dist/styles.css"
}
=======
packages/jsf-react/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "jsx": "react-jsx"
  },
  "include": [
    "src"
  ]
}=======
=======
