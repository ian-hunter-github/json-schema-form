// React adapter with const visibility/tagging options
import React, { useEffect, useMemo, useRef, useState } from "react";
import { createEngine, getByPath, sanitizeId } from "@totnesdev/jsf-core";
import type { JSONSchema, ValidationError } from "@totnesdev/jsf-core";

type ChangeCtx = { path: string; value: any; data: any; schema: JSONSchema; ts: number };
type ValidateCtx = { valid: boolean; errors: ValidationError[]; data: any; ts: number };

type ConstVisibility = "hidden" | "readonly" | "visible";
type ConstErrorStrategy = "suppress-when-managed" | "show";

export type JsonSchemaFormProps = {
  oneOfBranchTitleVisibility?: 'sr-only' | 'hidden' | 'visible';
  oneOfBranchShowDescription?: boolean;
  schema: JSONSchema;
  initialData?: any;
  classNamePrefix?: string;
  keepDataOnOneOfSwitch?: boolean;
  debounceMs?: number;
  debug?: boolean;

  // const/discriminator options
  constVisibility?: ConstVisibility;               // default 'hidden'
  autoConstTagging?: boolean;                      // default true
  constErrorStrategy?: ConstErrorStrategy;         // default 'suppress-when-managed'

  // existing callbacks
  onChange?: (data: any) => void;
  onSubmit?: (data: any) => void | Promise<void>;
  onValidate?: (ctx: ValidateCtx) => void | Promise<void>;
  onSubmitFailed?: (ctx: ValidateCtx) => void | Promise<void>;
  transformError?: (e: ValidationError) => ValidationError | null;

  onBeforeChange?: (ctx: ChangeCtx) => boolean | void | Promise<boolean | void>;
  onAfterChange?: (ctx: ChangeCtx) => void | Promise<void>;
  onBeforeSubmit?: (ctx: ValidateCtx) => boolean | void | Promise<boolean | void>;
  onBranchChange?: (info: { path: string; index: number; schema: any }) => void | Promise<void>;
  onArrayAdd?: (info: { path: string; index: number }) => void | Promise<void>;
  onArrayRemove?: (info: { path: string; index: number }) => void | Promise<void>;
  onReset?: (data: any) => void | Promise<void>;
  onSchemaLoad?: (schema: JSONSchema) => void | Promise<void>;
  showReset?: boolean;
};

function useDebounced(ms: number = 120) {
  const t = useRef<number | null>(null);
  const schedule = (fn: () => void) => {
    if (t.current) clearTimeout(t.current);
    t.current = window.setTimeout(() => { t.current = null; fn(); }, ms);
  };
  useEffect(() => () => { if (t.current) clearTimeout(t.current); }, []);
  return schedule;
}

function applyConstTagsForBranch(engine: any, path: string, branchSchema: any, enable: boolean) {
  if (!enable) return;
  const props = branchSchema?.properties || {};
  for (const k of Object.keys(props)) {
    const sub: any = (props as any)[k];
    if (sub && typeof sub === "object" && Object.prototype.hasOwnProperty.call(sub, "const")) {
      const p = path ? `${path}.${k}` : k;
      engine.setValue(p, sub.const);
    }
  }
}

export const JsonSchemaForm: React.FC<JsonSchemaFormProps> = ({
  schema,
  initialData,
  classNamePrefix = "jsf-",
  keepDataOnOneOfSwitch,
  debounceMs = 120,
  debug = false,
  constVisibility = "hidden",
  autoConstTagging = true,
  constErrorStrategy = "suppress-when-managed",
  onChange,
  onSubmit,
  onValidate,
  onSubmitFailed,
  transformError,
  onBeforeChange,
  onAfterChange,
  onBeforeSubmit,
  onBranchChange,
  onArrayAdd,
  onArrayRemove,
  onReset,
  onSchemaLoad,
  showReset = false
}) => {
  const engineRef = useRef(createEngine(schema, initialData, { keepDataOnOneOfSwitch }));
  const [tick, setTick] = useState(0);
  const schedule = useDebounced(debounceMs);
  const prefix = (c: string) => classNamePrefix + c;

  // Track const paths seen during render for error suppression
  const constPathsRef = useRef<Set<string>>(new Set());
  const resetConstPaths = () => { constPathsRef.current = new Set(); };

  useEffect(() => {
    engineRef.current.setSchema(schema);
    setTick(x => x + 1);
    (async () => { if (onSchemaLoad) await onSchemaLoad(schema); })();
  }, [schema, onSchemaLoad]);

  const firstMount = useRef(true);
  useEffect(() => {
    if (firstMount.current && initialData !== undefined) {
      engineRef.current.reset(initialData);
      firstMount.current = false;
    }
  }, [initialData]);

  const runPostChange = () => {
    schedule(async () => {
      const ok = engineRef.current.validate() as boolean;
      const st = engineRef.current.getState();
      let errs: ValidationError[] = st.errors;
      if (transformError) errs = (errs.map(transformError).filter(Boolean) as ValidationError[]);
      if (constErrorStrategy === "suppress-when-managed") {
        errs = errs.filter(e => !(e.keyword === "const" && constPathsRef.current.has(e.path)));
      }
      const ctx: ValidateCtx = { valid: ok, errors: errs, data: st.data, ts: Date.now() };
      if (onChange) onChange(st.data);
      if (onValidate) await onValidate(ctx);
      setTick(x => x + 1);
    });
  };

  const applyChange = async (path: string, value: any) => {
    const st0 = engineRef.current.getState();
    const ctx0: ChangeCtx = { path, value, data: st0.data, schema, ts: Date.now() };
    if (onBeforeChange) { const res = await onBeforeChange(ctx0); if (res === false) return; }
    engineRef.current.setValue(path, value);
    const st1 = engineRef.current.getState();
    const ctx1: ChangeCtx = { path, value, data: st1.data, schema, ts: Date.now() };
    if (onAfterChange) await onAfterChange(ctx1);
    setTick(x => x + 1);
    runPostChange();
  };

  const addItem = async (path: string) => {
    engineRef.current.addArrayItem(path);
    const arr = getByPath(engineRef.current.getState().data, path);
    const index = (Array.isArray(arr) ? arr.length : 1) - 1;
    if (onArrayAdd) await onArrayAdd({ path, index });
    setTick(x => x + 1);
    runPostChange();
  };

  const removeItem = async (path: string, i: number) => {
    engineRef.current.removeArrayItem(path, i);
    if (onArrayRemove) await onArrayRemove({ path, index: i });
    setTick(x => x + 1);
    runPostChange();
  };

  const setBranch = async (path: string, index: number, branchSchema: any) => {
    engineRef.current.setActiveBranch(path, index);
    applyConstTagsForBranch(engineRef.current, path, branchSchema, autoConstTagging);
    if (onBranchChange) await onBranchChange({ path, index, schema: branchSchema });
    setTick(x => x + 1);
    runPostChange();
  };

  const state = engineRef.current.getState();

  const errors: ValidationError[] = useMemo(() => {
    // Filtering is applied in runPostChange path; still compute here for live view
    let errs = state.errors;
    if (transformError) errs = (errs.map(transformError).filter(Boolean) as ValidationError[]);

    // Filter summary 'oneOf' error when a branch is selected at that path
    { const active = (state as any).activeOneOf || {};
      errs = errs.filter(e => !(e.keyword === "oneOf" && Object.prototype.hasOwnProperty.call(active, e.path)));
    }
    if (constErrorStrategy === "suppress-when-managed") {
      errs = errs.filter(e => !(e.keyword === "const" && constPathsRef.current.has(e.path)));
    }
    return errs;
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [tick, transformError, constErrorStrategy]);

  const handleSubmit: React.FormEventHandler<HTMLFormElement> = async (e) => {
    e.preventDefault();
    { const form = e.currentTarget as HTMLFormElement;
      if (nativeRequiredMode === 'enforce' && form && typeof form.reportValidity === 'function') {
        if (!form.reportValidity()) return;
      }
    }
    const ok = engineRef.current.validate() as boolean;
    const st = engineRef.current.getState();
    let errs: ValidationError[] = st.errors;
    if (transformError) errs = (errs.map(transformError).filter(Boolean) as ValidationError[]);
    if (constErrorStrategy === "suppress-when-managed") {
      errs = errs.filter(er => !(er.keyword === "const" && constPathsRef.current.has(er.path)));
    }
    const ctx: ValidateCtx = { valid: ok, errors: errs, data: st.data, ts: Date.now() };

    if (!ok) {
      if (onValidate) await onValidate(ctx);
      if (onSubmitFailed) await onSubmitFailed(ctx);
      if (errs[0]) {
        const id = sanitizeId(errs[0].path);
        document.getElementById(id)?.focus?.();
      }
      setTick(x => x + 1);
      return;
    }
    if (onValidate) await onValidate(ctx);
    if (onBeforeSubmit) { const proceed = await onBeforeSubmit(ctx); if (proceed === false) return; }
    if (onSubmit) await onSubmit(st.data);
    if (debug) alert(JSON.stringify(st.data, null, 2));
  };

  const fieldError = (path: string) => errors.find(e => e.path === path);

  const RenderField: React.FC<{ schema: any; path: string; required: boolean }> = ({ schema: s, path, required }) => {
    const t = Array.isArray(s?.type) ? s.type.find((x: any) => x !== "null") : s?.type;
    const id = sanitizeId(path);
    const title = (s?.title ?? (path ? path.split(".").slice(-1)[0] : "field")) || "field";
    const err = fieldError(path);
    const wrapCls = [prefix("field"), err ? "is-error" : ""].filter(Boolean).join(" ");

    // Handle const fields
    if (s && typeof s === "object" && Object.prototype.hasOwnProperty.call(s, "const")) {
      constPathsRef.current.add(path);
      if (autoConstTagging) engineRef.current.setValue(path, s.const);
      const display = typeof s.const === "string" ? s.const : JSON.stringify(s.const);
      if (constVisibility === "hidden") return null;
      if (constVisibility === "readonly") {
        return (
          <div className={wrapCls} data-field-name={path} data-field-type={"const"}>
            <label className={prefix("label")} htmlFor={id}>{title}{required ? " *" : ""}</label>
            <div className={prefix("input")} id={id} aria-readonly="true" style={{opacity:.8}}>
              {display}
            </div>
            {err && <div className={prefix("error")} id={id + "-err"}>{err.message}</div>}
          </div>
        );
      }
      // visible: disabled input
      return (
        <div className={wrapCls} data-field-name={path} data-field-type={"const"}>
          <label className={prefix("label")} htmlFor={id}>{title}{required ? " *" : ""}</label>
          <input className={prefix("input")} id={id} value={display} disabled aria-readonly="true" />
          {err && <div className={prefix("error")} id={id + "-err"}>{err.message}</div>}
        </div>
      );
    }

    // oneOf / anyOf
    if (Array.isArray(s?.oneOf) || Array.isArray(s?.anyOf)) {
      const group = s.oneOf || s.anyOf;
      const idx = state.activeOneOf[path] ?? 0;

      useEffect(() => {
        applyConstTagsForBranch(engineRef.current, path, group[idx], autoConstTagging);
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [idx]);

      return (
        <div className={wrapCls} data-field-name={path} data-field-type={"oneOf"}>
          <label className={prefix("label")} htmlFor={id}>{title}{required ? " *" : ""}</label>
          <select
            id={id}
            className={prefix("select")}
            value={String(idx)}
            onChange={(e) => setBranch(path, Number(e.target.value), group[Number(e.target.value)])}>
            {group.map((g: any, i: number) => <option key={i} value={String(i)}>{g.title ?? `${title} (${i + 1})`}</option>)}
          </select>
          <div className={prefix("object")}>
            <RenderField schema={group[idx]} path={path} required={required} />
          </div>
          {err && <div className={prefix("error")} id={id + "-err"}>{err.message}</div>}
        </div>
      );
    }

    // Enum
    if (Array.isArray(s?.enum)) {
      const value = getByPath(state.data, path);
      const strValue = typeof value === "string" ? value : (value == null ? "" : JSON.stringify(value));
      const labels: string[] = (s["x-enumNames"] || s["x-enum-labels"] || s.enum).map((x: any) => String(x));
      return (
        <div className={wrapCls} data-field-name={path} data-field-type={"enum"}>
          <label className={prefix("label")} htmlFor={id}>{title}{required ? " *" : ""}</label>
          <select
            id={id}
            className={prefix("select")}
            value={strValue}
            onChange={(e) => {
              let v: any = e.target.value;
              if (s.enum.some((x: any) => typeof x !== "string")) { try { v = JSON.parse(v); } catch {} }
              applyChange(path, v);
            }}>
            <option value="">-- select --</option>
            {s.enum.map((v: any, i: number) => (
              <option key={i} value={typeof v === "string" ? v : JSON.stringify(v)}>{labels[i]}</option>
            ))}
          </select>
          {err && <div className={prefix("error")} id={id + "-err"}>{err.message}</div>}
        </div>
      );
    }

    // Object (+ additionalProperties)
    if (t === "object" || s.properties) {
      const req: string[] = s.required || [];
      const objVal = getByPath(state.data, path) || {};
      const additionalSchema = s.additionalProperties && typeof s.additionalProperties === "object" ? s.additionalProperties : null;
      const extraKeys = additionalSchema ? Object.keys(objVal).filter((k: string) => !(s.properties || {})[k]) : [];

      return (
        <fieldset className={wrapCls + " " + prefix("object")} data-field-name={path} data-field-type={"object"}>
          <legend className={prefix("label")}>{title}{required ? " *" : ""}</legend>
          {Object.entries(s.properties || {}).map(([k, sub]) => (
            <RenderField key={k} schema={sub as any} path={path ? `${path}.${k}` : k} required={req.includes(k)} />
          ))}

          {additionalSchema && (
            <div style={{ marginTop: 6 }}>
              <strong>Additional properties</strong>
              {extraKeys.map(k => (
                <div key={k} style={{ display: "grid", gridTemplateColumns: "1fr auto", gap: 8, marginTop: 6 }}>
                  <RenderField schema={additionalSchema} path={path ? `${path}.${k}` : k} required={false} />
                  <button type="button" onClick={() => {
                    const next = { ...engineRef.current.getState().data };
                    const segs = path ? path.split(".") : [];
                    let cur: any = next;
                    for (const seg of segs) { cur[seg] = cur[seg] ?? {}; cur = cur[seg]; }
                    delete cur[k];
                    engineRef.current.reset(next);
                    setTick(x => x + 1);
                    runPostChange();
                  }}>Remove</button>
                </div>
              ))}
              <AddKeyRow path={path} />
            </div>
          )}
          {err && <div className={prefix("error")} id={id + "-err"}>{err.message}</div>}
        </fieldset>
      );
    }

    // Array
    if (t === "array" || s.items) {
      const items = Array.isArray(getByPath(state.data, path)) ? getByPath(state.data, path) : [];
      return (
        <div className={wrapCls} data-field-name={path} data-field-type={"array"}>
          <label className={prefix("label")} htmlFor={id}>{title}{required ? " *" : ""}</label>
          <div>
            {items.map((_v: any, i: number) => (
              <div key={i} style={{ marginBottom: 8 }}>
                <RenderField schema={s.items} path={`${path}.${i}`} required={false} />
                <button type="button" onClick={() => removeItem(path, i)}>Remove</button>
              </div>
            ))}
            <button type="button" onClick={() => addItem(path)}>Add</button>
          </div>
          {err && <div className={prefix("error")} id={id + "-err"}>{err.message}</div>}
        </div>
      );
    }

    // Primitive
    const format = s.format;
    let inputType: React.HTMLInputTypeAttribute = "text";
    if (format === "date") inputType = "date";
    else if (format === "time") inputType = "time";
    else if (format === "date-time") inputType = "datetime-local";
    else if (format === "email") inputType = "email";
    else if (format === "uri") inputType = "url";
    else if (format === "password") inputType = "password";
    else if (t === "number" || t === "integer") inputType = "number";
    else if (t === "boolean") inputType = "checkbox";

    const value = getByPath(state.data, path);
    const commonProps = { id, className: prefix("input"), "aria-invalid": !!err || undefined, "aria-describedby": err ? id + "-err" : undefined } as const;

    return (
      <div className={wrapCls} data-field-name={path} data-field-type={String(t ?? "unknown")}>
        <label className={prefix("label")} htmlFor={id}>{title}{required ? " *" : ""}</label>
        {inputType === "checkbox" ? (
          <input
            type="checkbox"
            {...commonProps}
            checked={!!value}
            onChange={(e) => applyChange(path, e.currentTarget.checked)}
          />
        ) : (
          <input
            type={inputType}
            {...commonProps}
            value={value ?? ""}
            onChange={(e) => {
              const raw = e.currentTarget.value;
              let v: any = raw;
              if (t === "number" || t === "integer") v = raw === "" ? undefined : Number(raw);
              applyChange(path, v);
            }}
          />
        )}
        {err && <div className={prefix("error")} id={id + "-err"}>{err.message}</div>}
      </div>
    );
  };

  const AddKeyRow: React.FC<{ path: string }> = ({ path }) => {
    const [key, setKey] = useState("");
    return (
      <div style={{ display: "flex", gap: 8, marginTop: 8 }}>
        <input className={prefix("input")} placeholder="new key" value={key} onChange={(e) => setKey(e.currentTarget.value)} />
        <button
          type="button"
          onClick={() => {
            const name = key.trim();
            if (!name) return;
            const next = { ...engineRef.current.getState().data };
            const segs = path ? path.split(".") : [];
            let cur: any = next;
            for (const seg of segs) { cur[seg] = cur[seg] ?? {}; cur = cur[seg]; }
            if (cur[name] !== undefined) return;
            cur[name] = undefined;
            engineRef.current.reset(next);
            setKey("");
            setTick(x => x + 1);
            runPostChange();
          }}>
          Add
        </button>
      </div>
    );
  };

  // reset const path tracking before each render pass
  resetConstPaths();

  const req: string[] = (schema as any).required || [];
  return (
    <form className={prefix("form")} noValidate onSubmit={handleSubmit}>
      {(schema as any).type === "object" || (schema as any).properties ? (
        Object.entries((schema as any).properties || {}).map(([k, s]) => (
          <RenderField key={k} schema={s as any} path={k} required={req.includes(k)} />
        ))
      ) : (
        <RenderField schema={schema as any} path={""} required={false} />
      )}

      <div style={{ marginTop: 12, display: "flex", gap: 8 }}>
        <button type="submit">Submit</button>
        {showReset && (
          <button
            type="button"
            onClick={async () => {
              engineRef.current.reset();
              setTick(x => x + 1);
              if (onReset) await onReset(engineRef.current.getState().data);
              runPostChange();
            }}>
            Reset
          </button>
        )}
      </div>

      {debug && (
        <pre style={{ background: "#fafafa", border: "1px solid #eee", padding: 8, borderRadius: 8, marginTop: 12 }}>
{JSON.stringify({ data: engineRef.current.getState().data, errors }, null, 2)}
        </pre>
      )}
    </form>
  );
};

export default JsonSchemaForm;
